# 代码的复用
1. 代码的资源化
2. 代码的抽象化
3. 函数是初步的抽象,对象是对函数的再一次抽象
---
# 程序模块化设计
1. 紧耦合：两个部分之间交流很多，无法独立存在
2. 松耦合：两个部分之间交流较少，可以独立存在
模块内部紧耦合，模块之间松耦合
---
# 函数递归的理解
1. 函数调用函数的方式就是递归
2. 计算过程存在递归链条
3. 基例：存在一个或多个或多个不需要再次递归的基例
*类似数学归纳法，在编程中体现*
---
## 递归的实现
```python
def fact():
    if n == 0:
        return 1
    else:
      return n*fact(n-1)
```
- 递归本身就是一个函数，需要函数定义方式描述
- 函数内部，采用分支语句对输入参数进行判断
- 基例和链条，分别编写对应代码
- 函数的计算机运行过程
---
# 字符串反转操作（关于上面的实例）
- 将字符串s反转后输出
```python
s[::-1] #以步长为负一来切片
def rvs(s):
  if s == '':
    return s
  else:
    return rvs(s[1:]+s[0])
```
# 斐波那契数列
```python
def f(n):
    if n== 1 or n == 2:
        return 1
    else:
        return f(n-1) + f(n-2)
```
# 汉诺塔问题
- 　　汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
```python
count = 0
def hanoi(n,src,dst,mid):#圆盘的数量,原柱子，目标柱子，过度柱子
    global count#全局变量
    if n == 1:
      print("{}:{}->{}".format(1,src,dst))
      count = count+1
    else:
      hanoi(n-1,src,mid,dst)
      print("{}:{}->{}".format(n,src,dst))
      count = count + 1
      hanoi(n-1,mid,dst,src)
```
